import copy
import random
from math import *
import numpy as np
from collections import defaultdict
import matplotlib.pyplot as plt
from numpy.polynomial import Polynomial
import time

# -------------------------------
# Constants & Global Variables
# -------------------------------
TIME_STEP = 10  # minutes per iteration
distance_cache = None

# -------------------------------
# Distance Cache Class
# -------------------------------
class DistanceCache:
    """Precompute all pairwise distances to avoid repeated calculations"""
    def __init__(self, graph):
        self.cache = {}
        self._precompute_all_distances(graph)
    
    def _precompute_all_distances(self, graph):
        for i in range(len(graph)):
            distances = dijkstra(graph, i)
            for j in range(len(graph)):
                self.cache[(i, j)] = distances[j]
    
    def get_distance(self, i, j):
        return self.cache.get((i, j), float('inf'))

def init_distance_cache(graph):
    """Initialize the global distance cache"""
    global distance_cache
    if distance_cache is None:
        distance_cache = DistanceCache(graph)
    return distance_cache

def get_distance(i, j):
    """Optimized distance lookup using cache"""
    global distance_cache
    if distance_cache is None:
        raise RuntimeError("Distance cache not initialized")
    return distance_cache.get_distance(i, j)

# -------------------------------
# Optimized Parking Helper Classes
# -------------------------------
class OptimizedParking:
    def __init__(self, graph):
        self.distance_cache = DistanceCache(graph)
        self.car_to_spot = {}
        self.spot_to_car = defaultdict(int)
        
    def update_mappings(self, spot_assignments):
        """Update internal dictionaries mapping cars to spots"""
        self.car_to_spot.clear()
        self.spot_to_car.clear()
        for spot, car in spot_assignments.items():
            if car != 0:
                self.car_to_spot[car] = spot
                self.spot_to_car[spot] = car

# -------------------------------
# Utility Functions
# -------------------------------
def create_inverse_mappings(assignments):
    """Return a dictionary car -> spot"""
    car_to_spot = {}
    for spot, car in assignments.items():
        if car != 0:
            car_to_spot[car] = spot
    return car_to_spot

def min_value(lst):
    return min(lst)

def max_value(lst):
    return max(lst)

def remove_max(lst):
    """Remove and return max element (used in ordering)"""
    m = -float('inf')
    idx = 0
    for i, val in enumerate(lst):
        if val[0] > m:
            m = val[0]
            idx = i
    return lst.pop(idx)

def remove_min_dict(d):
    """Remove and return (key, value) of minimum in dictionary"""
    min_key = min(d, key=d.get)
    return min_key, d.pop(min_key)

def dijkstra(graph, start_node):
    """Standard Dijkstra algorithm for shortest paths"""
    nodes_to_process = {start_node: 0}
    distances = [0] * len(graph)
    
    while nodes_to_process:
        node, dist = remove_min_dict(nodes_to_process)
        current_distance = distances[node]
        for j in range(len(graph)):
            if graph[node][j] != 0:
                new_distance = current_distance + graph[node][j]
                if (distances[j] == 0 or distances[j] > new_distance) and (j not in nodes_to_process or nodes_to_process[j] > new_distance):
                    nodes_to_process[j] = new_distance
                    if j != start_node:
                        distances[j] = new_distance
    return distances

# -------------------------------
# Regret Calculations
# -------------------------------
def calculate_regret(assignments, cars_list, car_index, car_prefs, spot_coords):
    """Compute regret of assigning a specific car"""
    car_to_spot = create_inverse_mappings(assignments)
    current_spot = car_to_spot.get(car_index, 0)
    pref_dict = {c[0]: c[1] for c in car_prefs}
    prefs = pref_dict.get(car_index, [])
    
    for i, preferred_spot in enumerate(prefs):
        if spot_coords[preferred_spot] == current_spot:
            return len(cars_list) - i
    return 0
tipe_multiple_graphs()  # Graphiques séparés